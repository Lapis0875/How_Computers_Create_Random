세상에는 확률적으로 일어나는 수많은 사건들이 존재합니다. 
근래에는, 컴퓨터에서 동작하는 게임 등의 프로그램에도 확률적으로 진행되는 이벤트 등이 다수 존재합니다.
컴퓨터에서는 확률, 그 중에서도 무작위의 확률(random) 을 어떻게 구현하는지, 우리가 게임에서 랜덤이라고 부르는 것은 진정한 랜덤이 맞는지 궁금해졌습니다.

# 컴퓨터로 계산하는 랜덤
컴퓨터는 정해진 계산 과정을 통해 값을 도출합니다. 그렇기에, 완전히 무작위의 확률을 계산하는 것은 컴퓨터 혼자서는 불가능한 일입니다.
자연적인 랜덤(True random)은 컴퓨터 밖에서 일어나는 특정한 물리적인 현상을 관측해, 그 데이터를 토대로 랜덤한 값을 생성하는 방식을 사용합니다.
예를 들어, 원자의 분해 (atom decay, radioactive decay) 를 관측하거나, 주변의 잡음을 측정하거나, 혹은 키보드를 누른 시간과 눌린 키의 정보 등을 사용해 자연적인 랜덤을 구현할 수 있습니다.
의사 난수(Pseudorandom)는 시드 값과 알고리즘을 활용해, 랜덤한 값을 만들어내는 방식입니다.
게임과 같은 경우에서는 어떤 방식의 랜덤을 사용하던 크게 상관 없습니다.
그러나, 암호화와 같은 보안 분야에서는 랜덤은 매우 중요한 사안입니다.
공격자가 랜덤 값을 예측하면, 암호화를 풀어내어 중요한 정보를 훔칠 수 있기 때문입니다.

# 현재 컴퓨터에서 사용하는 랜덤 숫자 생성기
랜덤 숫자 생성기 (Random numbers generator, RNG) 는 크게 두가지로 구분됩니다.
CPU 등의 하드웨어적인 장치로부터 물리 현상을 관측해, 자연적인 랜덤에 가까운 방식으로 난수 값을 생성하는 Hardware Random Number Generators (HRNGS) 와,
의사 난수 방식으로, 특정한 알고리즘을 사용해 시드 값을 기준으로 난수값을 도출해내는 Pseudorandom Number Generators (PRNGS) 의 방식이 있습니다.

# 의사 난수 생성 알고리즘들
의사 난수 생성 알고리즘의 몇가지 예시를 조사해 보았습니다.

## 1. 중앙제곱법 (Mid Square Method) - 폰 노이만 (1949)
중앙제곱법은 폰 노이만이 1949년에 고안한 의사 난수 생성법으로, 임의의 숫자를 제곱한 다음 이 숫자의 일부분을 사용해 새로운 난수를 만드는 방법입니다.
1234를 초기값으로 해, 임의의 4자리 난수를 만든다고 가정해보겠습니다.

|페이즈|대상값|제곱값|난수|
|:---:|:---:|:---:|:---:|
|0|1234|1522756|5227|
|1|5227|27321529|3215|
|2|3215|10336225|3362|

중앙제곱법은 중앙에 있는 값을 다시 제곱하면서 임의의 난수를 생성하는 방식으로 동작합니다. 
간단한 방법이므로, 예측되기 쉬워 요즘에는 거의 사용되지 않습니다.

## 2. 선형합동법 (Linear Congruential Method)
선형합동법은 C언어의 rand함수에서 사용하는 알고리즘입니다.
선형합동법은 다음과 같은 재귀 관계식으로 정의되며, 난수들의 수열을 반환합니다.
```
X_n+1 = (a × X_n + c) mod m
```
선형합동법의 특징은 이전에 생성된 난수를 활용한다는 것이며, 최대 m만큼 경우의 수를 가지므로 최악의 경우 m 만큼의 반복 주기를 가집니다.
m 변수에 작은 수를 할당한 다음, 다시 난수를 만들어보면 동일한 난수 값이 눈에 띄게 많이 출현하는 것을 확인할 수 있습니다.
선형합동법은 계산이 굉장히 간단하고 빠르기 때문에 초창기부터 컴퓨터에 널리 사용되었습니다.
그러나, 선형합동법은 난수에 주기성이 있고 생성되어 나오는 난수들 사이에 상관 관계가 존재하기 때문에 마지막으로 생성된 난수와 그 외 변수들만 알면 그 다음에 생성될 난수를 모두 예측할 수 있습니다.
하지만, 현재 이 변수들은 ANSI C 표준으로 정해져 있어 누구나 알 수 있습니다.
즉, 조금 지식이 있는 사람이면 rand 함수의 결과를 보고 다음 난수를 미리 예상할 수 있다는 것입니다.
그래서 이 알고리즘은 난수가 예측되어도 상관없는 경우나 임베디드처럼 메모리를 많이 사용하지 못하는 제한된 상황에서 주로 사용합니다.

## 3. 메르센 트위스터 (Mersenne Twister)
메르센 트위스터는 1997년에 마츠모토 마코토와 니시무라 다쿠지가 개발한 알고리즘으로, 현재 엑셀, MATLAB, PHP, Python, R, C++ 등에서 난수 생성 알고리즘으로 사용하고 있습니다.
메르센 트위스터라는 이름은 이 알고리즘의 난수 반복 주기가 메르센 소수인데서 유래했습니다.
메르센 수는 `M_n = 2^n - 1`으로 나타내며 식 그대로 2의 n 제곱에서 1이 모자란 수를 말합니다.
메르센 소수는 이 메르센 수 중에서 소수인 수들을 칭합니다.
보통 2^19937 - 1의 난수 반복 주기를 가지는 MT19937이 많이 사용되는데, C++에서도 이 알고리즘을 채택해서 사용하고 있습니다.
이 알고리즘의 동작 원리를 간단하게 설명하면 다음과 같습니다.

> 1. seed 를 사용하여 624 만큼의 길이를 가진 벡터를 생성. seed 는 보통 하드웨어 노이즈나 오늘 날짜를 사용한다.
> 2. 이 벡터를 사용하여 624개의 유사 난수를 만든다.
> 3. 이 벡터에 노이즈를 준 후 다시 2번을 반복. 이 노이즈를 주는 행위를 Twist 한다고 한다.

이때 Twist 하는 과정에서, GFSR(Generalized Feedback Shift Register) 라는 방법을 사용합니다.
GFSR은 LFSR(Linear Feedback Shift Register)를 변형한 방법입니다. (논문 등의 내용을 완전히 이해하지 못해, 참고한 블로그의 정보를 가져왔습니다. 정확하지 않을 수 있습니다.)
LFSR은 이전 상태의 값들로 선형 함수를 통해 계산한 후, 이를 사용해서 다음 값을 만들어 내는 방법입니다.
보통 XOR 함수를 많이 사용하고, 초기값을 시드(Seed)라고 부릅니다.

---
**출처**
1. 컴퓨터와 의사난수 
- http://www.ksn.or.kr/file/journal/701525349/2010/618-628.pdf
- https://theconversation.com/how-random-is-your-randomness-and-why-does-it-matter-59958
- https://softwareengineering.stackexchange.com/questions/109724/how-do-random-number-generators-work
- https://en.wikipedia.org/wiki/Random_number_generation
2. 의사난수 생성 알고리즘
- 의사난수 생성 알고리즘 : https://evan-moon.github.io/2019/07/14/what-is-random
- 메르센 트위스터 구현 : https://choiseokwon.tistory.com/244

